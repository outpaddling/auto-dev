#!/bin/sh -e

##########################################################################
#   Synopsis:
#       auto-script2man script-filename [script-filename ...]
#       
#   Description:
#       auto-script2man generates a man page from an embedded comment
#       in the script.
#       Within the script file there must be a block
#       comment containining all the sections of the man page.  Each
#       of the following must be present on a separate line within the
#       block comment:
#
#       # Title:
#       
#       Followed by a man-page title, if different from the script name.
#       Otherwise, the title is the filename of the script, minus extension.
#       
#       # Synopsis:
#
#       Followed by a script invocation template typical of
#       the usage message of a Unix command or the synopsis in a
#       typical man page.
#
#       # Description:
#
#       Followed by multiple lines of text describing the purpose of the
#       script and how to use it.
#
#       # Arguments:
#
#       Followed by one line describing each command-line argument
#
#       # Returns:
#
#       Exit status returned by the script
#
#       # Examples:
#       
#       Sufficient examples of running the script to cover typical use cases
#
#       # See also:
#       
#       List of related scripts and commands, e.g. auto-c2man(1)
#       
#   Arguments:
#       script-filename     File containing the script
#       
#   Returns:
#       0 on success, non-zero error codes otherwise
#
#   Examples:
#       auto-script2man script.sh
#
#   See also:
#       auto-c2man(1), auto-gen-get-set(1)
#
#   History:
#   Date        Name        Modification
#   2021-04-23  Jason Bacon Begin
##########################################################################

usage()
{
    printf "Usage: $0 source-file [source file ...]\n"
    exit 1
}


##########################################################################
#   Function description:
#       Pause until user presses return
##########################################################################

pause()
{
    local junk
    
    printf "Press return to continue..."
    read junk
}


##########################################################################
#   Function description:
#       Generate a man page for the script
#       
#   History:
#   Date        Name        Modification
#   2021-04-23  Jason Bacon Begin
##########################################################################

gen_page()
{
    FILE_LIST="$FILE_LIST Temp-man/$title.$section"
    cat << EOM > Temp-man/$title.$section
\" Generated by script2man from $title
.TH $title $section

\" Convention:
\" Underline anything that is typed verbatim - commands, etc.
.SH SYNOPSIS
.PP
.nf 
.na
$(cat script2man-synopsis)
.ad
.fi

.SH ARGUMENTS
.nf
.na
$(cat script2man-arguments)
.ad
.fi

.SH DESCRIPTION
$(cat script2man-description)
EOM

    if [ -e script2man-returns ]; then
	cat << EOM >> Temp-man/$title.$section

.SH RETURN VALUES
$(cat script2man-returns)
EOM
    fi
    
    if [ -e script2man-examples ]; then
	cat << EOM >> Temp-man/$title.$section

.SH EXAMPLES
.nf
.na
$(cat script2man-examples)
.ad
.fi
EOM
    fi
    
    if [ -e script2man-files ]; then
	cat << EOM >> Temp-man/$title.$section

.SH FILES
.nf
.na
$(cat script2man-files)
.ad
.fi
EOM
    fi

    if [ -e script2man-env ]; then
	cat << EOM >> Temp-man/$title.$section

.SH ENVIRONMENT
$(cat script2man-env)
EOM
    fi
    
    if [ -e script2man-see-also ]; then
	cat << EOM >> Temp-man/$title.$section

.SH SEE ALSO
$(cat script2man-see-also)

EOM
    fi
    return
}


##########################################################################
#   Main
##########################################################################

if [ $# -lt 1 ]; then
    usage
fi

mkdir -p Temp-man
rm -f script2man-*
for source_file in "$@"; do
    printf "Parsing $source_file...\n"
    
    # Just defaults to be overridden by input
    title=$(basename $source_file)
    section=1
    
    mode=ignore
    main_comment=n
    my_tty=$(tty)
    
    while read line && [ $mode != done ]; do
	# A Synopsis: line is required          
	if echo $line | grep -q '^[ ]*\#[ ]*Title:'; then
	    mode=title
	    line=''
	elif echo $line | grep -q '^[ ]*\#[ ]*Section:'; then
	    mode=section
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Synopsis:'; then
	    mode=synopsis
	    line=''
	    # Set this state variable upon finding the synopsis
	    # The script now knows it's parsing the man page template
	    main_comment=y
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Description:'; then
	    mode=description
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Arguments:'; then
	    mode=arguments
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Returns'; then
	    mode=returns
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Examples:'; then
	    mode=examples
	    line=''
	    line_count=0
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Files:'; then
	    mode=files
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*Environment:'; then
	    mode=env
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*See also:'; then
	    mode=see-also
	    line=''
	elif echo "$line" | grep -q '^[ ]*\#[ ]*History'; then
	    mode=ignore
	    line=''
	elif echo "$line" | grep -q '^####' && [ $main_comment = y ]; then
	    mode=done
	    gen_page
	    main_comment=n
	    rm script2man-*
	fi
    
	case $mode in
	title)
	    if [ ! -z "$line" ]; then
		if [ -z "$title_set" ]; then
		    title=$(echo "$line" | sed -e 's|^ *# *||')
		fi
		# Avoid setting title again using blank lines below
		title_set=yes
	    fi
	    ;;
	    
	section)
	    if [ ! -z "$line" ]; then
		if [ -z "$section_set" ]; then
		    section=$(echo "$line" | sed -e 's|^ *# *||')
		fi
		# Avoid setting section again using blank lines below
		section_set=yes
	    fi
	    ;;
	    
	synopsis)
	    if [ ! -z "$line" ]; then
		line=$(echo "$line" | sed -e 's|^ *# *||')
		echo "$line" >> script2man-synopsis
	    fi
	    ;;
	    
	description)
	    line=$(echo "$line" | sed -e 's|^ *# *||')
	    echo "$line" >> script2man-description
	    ;;
	    
	arguments)
	    line=$(echo "$line" | sed -e 's|^ *# *||')
	    if [ ! -z "$line" ]; then
		echo "$line" >> script2man-arguments
	    fi
	    ;;
	    
	returns)
	    line=$(echo "$line" | sed -e 's|^ *# *||')
	    echo "$line" >> script2man-returns
	    ;;
	    
	examples)
	    # First line is not real, just from line=''
	    # Respect blanks after that
	    if [ $line_count -gt 0 ]; then
		# Trim a specific number of leading spaces for nroff no-fill,
		# no-adjust environment.  Then trim trailing spaces.
		line=$(echo "$line" | sed -e 's|^ *#       ||')
		line=$(echo "$line" | sed -e 's|^ *# *$||')
		echo "$line" >> script2man-examples
	    fi
	    line_count=$(($line_count + 1))
	    ;;
	    
	files)
	    if [ ! -z "$line" ]; then
		line=$(echo "$line" | sed -e 's|^ *# *||')
		echo "$line" >> script2man-files
	    fi
	    ;;
	    
	env)
	    line=$(echo "$line" | sed -e 's|^ *# *||')
	    echo "$line" >> script2man-env
	    ;;
	    
	see-also)
	    line=$(echo "$line" | sed -e 's|^ *# *||')
	    echo "$line" >> script2man-see-also
	    ;;
	    
	history)
	    ;;
	    
	*)
	    ;;
	    
	esac
    done < $source_file
done

ape $FILE_LIST

